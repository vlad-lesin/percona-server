include/rpl_init.inc [topology=1->2->3]
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the master info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START SLAVE; see the 'START SLAVE Syntax' in the MySQL Manual for more information.
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the master info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START SLAVE; see the 'START SLAVE Syntax' in the MySQL Manual for more information.
DROP TABLE IF EXISTS `t`;
Warnings:
Note	1051	Unknown table 'test.t'
CREATE TABLE `t` (
`f1` int(10) unsigned NOT NULL,
PRIMARY KEY (`f1`)
) ENGINE=InnoDB;
DROP TABLE IF EXISTS `t2`;
Warnings:
Note	1051	Unknown table 'test.t2'
CREATE TABLE `t2` (
`f1` int(10) unsigned NOT NULL,
PRIMARY KEY (`f1`)
) ENGINE=InnoDB;
DROP TRIGGER IF EXISTS `t_insert_trig`;
Warnings:
Note	1360	Trigger does not exist
================================
= Testing for fix of lp:1464468,
= if there is no assertion in debug
= build then the test is passed.
================================
CREATE TRIGGER `t_insert_trig` AFTER INSERT ON `t`
	FOR EACH ROW 
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO `savepoint_1`;
# If the bug is not fixed then debug build will crash here with assertion.
END;
SAVEPOINT `savepoint_1`;
INSERT INTO `dummy` VALUES (1);
END |
INSERT INTO `t` VALUES (2);
INSERT INTO `t` VALUES (3);
DROP TRIGGER `t_insert_trig`;
================================
= Testing for fix of lp:1483251.
= There must be "COMMIT" after 
= trigger's body execution in
= binary log.
================================
CREATE TRIGGER `t_insert_trig` AFTER INSERT ON `t`
	FOR EACH ROW 
BEGIN
SAVEPOINT `savepoint_1`;
END |
INSERT INTO `t` VALUES (4);
INSERT INTO `t` VALUES (5);
DROP TRIGGER `t_insert_trig`;
=================================================
= Except lp:1483251 this also tests lp:438990,
= i.e. table map must be written after SAVEPOINT
= and before the next statement in trigger or sp.
=================================================
CREATE TRIGGER `t_insert_trig` AFTER INSERT ON t
FOR EACH ROW 
BEGIN
SAVEPOINT `savepoint_1`;
INSERT INTO `t2` VALUES (NEW.f1);
END |
INSERT INTO `t` VALUES (6);
INSERT INTO `t` VALUES (7);
DROP TRIGGER `t_insert_trig`;
=================================================
= Test for lp:438990,
= i.e. table map must be written after SAVEPOINT
= and before the next statement in trigger or sp.
=================================================
CREATE PROCEDURE `p1`(IN param INT)
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO `savepoint_1`;
INSERT `t2` VALUES (param);
END;
SAVEPOINT `savepoint_1`;
INSERT INTO dummy VALUES (1);
RELEASE SAVEPOINT `savepoint_1`;
END|
CREATE TRIGGER `t_insert_trig` AFTER INSERT ON `t` FOR EACH ROW CALL `p1`(NEW.f1)|
INSERT INTO `t` VALUES (8);
INSERT INTO `t` VALUES (9);
DROP PROCEDURE `p1`;
DROP TRIGGER `t_insert_trig`;
=================================================
= Test for savepoints outside of SP or trigger
=================================================
BEGIN;
INSERT INTO `t` VALUES (10);
SAVEPOINT `savepoint_1`;
INSERT INTO `t` VALUES (11);
COMMIT;
BEGIN;
INSERT INTO `t` VALUES (12);
SAVEPOINT `savepoint_1`;
INSERT INTO `t` VALUES (13);
ROLLBACK TO SAVEPOINT `savepoint_1`;
COMMIT;
===================================================
= Test for SPs and functions. Must work independent
= of the fix.
===================================================
CREATE PROCEDURE `p1`(IN param INT)
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO savepoint1;
INSERT `t2` VALUES (param);
END;
START TRANSACTION;
SAVEPOINT savepoint1;
INSERT INTO dummy VALUES (1);
RELEASE SAVEPOINT `savepoint_1`;
COMMIT;
END|
CREATE PROCEDURE `p2`()
BEGIN
START TRANSACTION;
SAVEPOINT savepoint1;
COMMIT;
END|
CREATE FUNCTION func(param INT) RETURNS INT
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO savepoint1;
INSERT `t2` VALUES (param);
RETURN 2;
END;
SAVEPOINT savepoint1;
INSERT INTO dummy VALUES (1);
RELEASE SAVEPOINT `savepoint_1`;
RETURN 1;
END|
CALL p1(1000);
CALL p2();
SELECT func(2000);
func(2000)
2
DROP PROCEDURE p1;
DROP PROCEDURE p2;
DROP FUNCTION func;
DROP TABLE `t`;
DROP TABLE `t2`;
==============================
= Server 1 binary log
==============================
include/show_binlog_events.inc
Log_name	Pos	Event_type	Server_id	End_log_pos	Info
master-bin.000001	#	Query	#	#	use `test`; DROP TABLE IF EXISTS `t` /* generated by server */
master-bin.000001	#	Query	#	#	use `test`; CREATE TABLE `t` (
`f1` int(10) unsigned NOT NULL,
PRIMARY KEY (`f1`)
) ENGINE=InnoDB
master-bin.000001	#	Query	#	#	use `test`; DROP TABLE IF EXISTS `t2` /* generated by server */
master-bin.000001	#	Query	#	#	use `test`; CREATE TABLE `t2` (
`f1` int(10) unsigned NOT NULL,
PRIMARY KEY (`f1`)
) ENGINE=InnoDB
master-bin.000001	#	Query	#	#	use `test`; DROP TRIGGER IF EXISTS `t_insert_trig`
master-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` TRIGGER `t_insert_trig` AFTER INSERT ON `t`
	FOR EACH ROW 
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO `savepoint_1`;
# If the bug is not fixed then debug build will crash here with assertion.
END;
SAVEPOINT `savepoint_1`;
INSERT INTO `dummy` VALUES (1);
END
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Write_rows	#	#	table_id: #
master-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Write_rows	#	#	table_id: #
master-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	use `test`; DROP TRIGGER `t_insert_trig`
master-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` TRIGGER `t_insert_trig` AFTER INSERT ON `t`
	FOR EACH ROW 
BEGIN
SAVEPOINT `savepoint_1`;
END
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Write_rows	#	#	table_id: #
master-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Write_rows	#	#	table_id: #
master-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	use `test`; DROP TRIGGER `t_insert_trig`
master-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` TRIGGER `t_insert_trig` AFTER INSERT ON t
FOR EACH ROW 
BEGIN
SAVEPOINT `savepoint_1`;
INSERT INTO `t2` VALUES (NEW.f1);
END
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
master-bin.000001	#	Write_rows	#	#	table_id: #
master-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
master-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
master-bin.000001	#	Write_rows	#	#	table_id: #
master-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
master-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	use `test`; DROP TRIGGER `t_insert_trig`
master-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` PROCEDURE `p1`(IN param INT)
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO `savepoint_1`;
INSERT `t2` VALUES (param);
END;
SAVEPOINT `savepoint_1`;
INSERT INTO dummy VALUES (1);
RELEASE SAVEPOINT `savepoint_1`;
END
master-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` TRIGGER `t_insert_trig` AFTER INSERT ON `t` FOR EACH ROW CALL `p1`(NEW.f1)
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
master-bin.000001	#	Write_rows	#	#	table_id: #
master-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
master-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
master-bin.000001	#	Write_rows	#	#	table_id: #
master-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
master-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	use `test`; DROP PROCEDURE `p1`
master-bin.000001	#	Query	#	#	use `test`; DROP TRIGGER `t_insert_trig`
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
master-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Table_map	#	#	table_id: # (test.t)
master-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
master-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` PROCEDURE `p1`(IN param INT)
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO savepoint1;
INSERT `t2` VALUES (param);
END;
START TRANSACTION;
SAVEPOINT savepoint1;
INSERT INTO dummy VALUES (1);
RELEASE SAVEPOINT `savepoint_1`;
COMMIT;
END
master-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` PROCEDURE `p2`()
BEGIN
START TRANSACTION;
SAVEPOINT savepoint1;
COMMIT;
END
master-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` FUNCTION `func`(param INT) RETURNS int(11)
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO savepoint1;
INSERT `t2` VALUES (param);
RETURN 2;
END;
SAVEPOINT savepoint1;
INSERT INTO dummy VALUES (1);
RELEASE SAVEPOINT `savepoint_1`;
RETURN 1;
END
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
master-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	BEGIN
master-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
master-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
master-bin.000001	#	Xid	#	#	COMMIT /* XID */
master-bin.000001	#	Query	#	#	use `test`; DROP PROCEDURE p1
master-bin.000001	#	Query	#	#	use `test`; DROP PROCEDURE p2
master-bin.000001	#	Query	#	#	use `test`; DROP FUNCTION func
master-bin.000001	#	Query	#	#	use `test`; DROP TABLE `t` /* generated by server */
master-bin.000001	#	Query	#	#	use `test`; DROP TABLE `t2` /* generated by server */
include/rpl_sync.inc
==============================
= Server 2 binary log
==============================
include/show_binlog_events.inc
Log_name	Pos	Event_type	Server_id	End_log_pos	Info
slave-bin.000001	#	Query	#	#	use `test`; DROP TABLE IF EXISTS `t` /* generated by server */
slave-bin.000001	#	Query	#	#	use `test`; CREATE TABLE `t` (
`f1` int(10) unsigned NOT NULL,
PRIMARY KEY (`f1`)
) ENGINE=InnoDB
slave-bin.000001	#	Query	#	#	use `test`; DROP TABLE IF EXISTS `t2` /* generated by server */
slave-bin.000001	#	Query	#	#	use `test`; CREATE TABLE `t2` (
`f1` int(10) unsigned NOT NULL,
PRIMARY KEY (`f1`)
) ENGINE=InnoDB
slave-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` TRIGGER `t_insert_trig` AFTER INSERT ON `t`
	FOR EACH ROW 
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO `savepoint_1`;
# If the bug is not fixed then debug build will crash here with assertion.
END;
SAVEPOINT `savepoint_1`;
INSERT INTO `dummy` VALUES (1);
END
slave-bin.000001	#	Query	#	#	BEGIN
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
slave-bin.000001	#	Xid	#	#	COMMIT /* XID */
slave-bin.000001	#	Query	#	#	BEGIN
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
slave-bin.000001	#	Xid	#	#	COMMIT /* XID */
slave-bin.000001	#	Query	#	#	use `test`; DROP TRIGGER `t_insert_trig`
slave-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` TRIGGER `t_insert_trig` AFTER INSERT ON `t`
	FOR EACH ROW 
BEGIN
SAVEPOINT `savepoint_1`;
END
slave-bin.000001	#	Query	#	#	BEGIN
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
slave-bin.000001	#	Xid	#	#	COMMIT /* XID */
slave-bin.000001	#	Query	#	#	BEGIN
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
slave-bin.000001	#	Xid	#	#	COMMIT /* XID */
slave-bin.000001	#	Query	#	#	use `test`; DROP TRIGGER `t_insert_trig`
slave-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` TRIGGER `t_insert_trig` AFTER INSERT ON t
FOR EACH ROW 
BEGIN
SAVEPOINT `savepoint_1`;
INSERT INTO `t2` VALUES (NEW.f1);
END
slave-bin.000001	#	Query	#	#	BEGIN
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Xid	#	#	COMMIT /* XID */
slave-bin.000001	#	Query	#	#	BEGIN
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Xid	#	#	COMMIT /* XID */
slave-bin.000001	#	Query	#	#	use `test`; DROP TRIGGER `t_insert_trig`
slave-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` PROCEDURE `p1`(IN param INT)
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO `savepoint_1`;
INSERT `t2` VALUES (param);
END;
SAVEPOINT `savepoint_1`;
INSERT INTO dummy VALUES (1);
RELEASE SAVEPOINT `savepoint_1`;
END
slave-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` TRIGGER `t_insert_trig` AFTER INSERT ON `t` FOR EACH ROW CALL `p1`(NEW.f1)
slave-bin.000001	#	Query	#	#	BEGIN
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Xid	#	#	COMMIT /* XID */
slave-bin.000001	#	Query	#	#	BEGIN
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Xid	#	#	COMMIT /* XID */
slave-bin.000001	#	Query	#	#	use `test`; DROP PROCEDURE `p1`
slave-bin.000001	#	Query	#	#	use `test`; DROP TRIGGER `t_insert_trig`
slave-bin.000001	#	Query	#	#	BEGIN
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Xid	#	#	COMMIT /* XID */
slave-bin.000001	#	Query	#	#	BEGIN
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
slave-bin.000001	#	Xid	#	#	COMMIT /* XID */
slave-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` PROCEDURE `p1`(IN param INT)
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO savepoint1;
INSERT `t2` VALUES (param);
END;
START TRANSACTION;
SAVEPOINT savepoint1;
INSERT INTO dummy VALUES (1);
RELEASE SAVEPOINT `savepoint_1`;
COMMIT;
END
slave-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` PROCEDURE `p2`()
BEGIN
START TRANSACTION;
SAVEPOINT savepoint1;
COMMIT;
END
slave-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` FUNCTION `func`(param INT) RETURNS int(11)
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO savepoint1;
INSERT `t2` VALUES (param);
RETURN 2;
END;
SAVEPOINT savepoint1;
INSERT INTO dummy VALUES (1);
RELEASE SAVEPOINT `savepoint_1`;
RETURN 1;
END
slave-bin.000001	#	Query	#	#	BEGIN
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Xid	#	#	COMMIT /* XID */
slave-bin.000001	#	Query	#	#	BEGIN
slave-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
slave-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
slave-bin.000001	#	Xid	#	#	COMMIT /* XID */
slave-bin.000001	#	Query	#	#	use `test`; DROP PROCEDURE p1
slave-bin.000001	#	Query	#	#	use `test`; DROP PROCEDURE p2
slave-bin.000001	#	Query	#	#	use `test`; DROP FUNCTION func
slave-bin.000001	#	Query	#	#	use `test`; DROP TABLE `t` /* generated by server */
slave-bin.000001	#	Query	#	#	use `test`; DROP TABLE `t2` /* generated by server */
include/rpl_sync.inc
==============================
= Server 3 binary log
==============================
include/show_binlog_events.inc
Log_name	Pos	Event_type	Server_id	End_log_pos	Info
mysqld-bin.000001	#	Query	#	#	use `test`; DROP TABLE IF EXISTS `t` /* generated by server */
mysqld-bin.000001	#	Query	#	#	use `test`; CREATE TABLE `t` (
`f1` int(10) unsigned NOT NULL,
PRIMARY KEY (`f1`)
) ENGINE=InnoDB
mysqld-bin.000001	#	Query	#	#	use `test`; DROP TABLE IF EXISTS `t2` /* generated by server */
mysqld-bin.000001	#	Query	#	#	use `test`; CREATE TABLE `t2` (
`f1` int(10) unsigned NOT NULL,
PRIMARY KEY (`f1`)
) ENGINE=InnoDB
mysqld-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` TRIGGER `t_insert_trig` AFTER INSERT ON `t`
	FOR EACH ROW 
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO `savepoint_1`;
# If the bug is not fixed then debug build will crash here with assertion.
END;
SAVEPOINT `savepoint_1`;
INSERT INTO `dummy` VALUES (1);
END
mysqld-bin.000001	#	Query	#	#	BEGIN
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
mysqld-bin.000001	#	Xid	#	#	COMMIT /* XID */
mysqld-bin.000001	#	Query	#	#	BEGIN
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
mysqld-bin.000001	#	Xid	#	#	COMMIT /* XID */
mysqld-bin.000001	#	Query	#	#	use `test`; DROP TRIGGER `t_insert_trig`
mysqld-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` TRIGGER `t_insert_trig` AFTER INSERT ON `t`
	FOR EACH ROW 
BEGIN
SAVEPOINT `savepoint_1`;
END
mysqld-bin.000001	#	Query	#	#	BEGIN
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
mysqld-bin.000001	#	Xid	#	#	COMMIT /* XID */
mysqld-bin.000001	#	Query	#	#	BEGIN
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
mysqld-bin.000001	#	Xid	#	#	COMMIT /* XID */
mysqld-bin.000001	#	Query	#	#	use `test`; DROP TRIGGER `t_insert_trig`
mysqld-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` TRIGGER `t_insert_trig` AFTER INSERT ON t
FOR EACH ROW 
BEGIN
SAVEPOINT `savepoint_1`;
INSERT INTO `t2` VALUES (NEW.f1);
END
mysqld-bin.000001	#	Query	#	#	BEGIN
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Xid	#	#	COMMIT /* XID */
mysqld-bin.000001	#	Query	#	#	BEGIN
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Xid	#	#	COMMIT /* XID */
mysqld-bin.000001	#	Query	#	#	use `test`; DROP TRIGGER `t_insert_trig`
mysqld-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` PROCEDURE `p1`(IN param INT)
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO `savepoint_1`;
INSERT `t2` VALUES (param);
END;
SAVEPOINT `savepoint_1`;
INSERT INTO dummy VALUES (1);
RELEASE SAVEPOINT `savepoint_1`;
END
mysqld-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` TRIGGER `t_insert_trig` AFTER INSERT ON `t` FOR EACH ROW CALL `p1`(NEW.f1)
mysqld-bin.000001	#	Query	#	#	BEGIN
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Xid	#	#	COMMIT /* XID */
mysqld-bin.000001	#	Query	#	#	BEGIN
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Xid	#	#	COMMIT /* XID */
mysqld-bin.000001	#	Query	#	#	use `test`; DROP PROCEDURE `p1`
mysqld-bin.000001	#	Query	#	#	use `test`; DROP TRIGGER `t_insert_trig`
mysqld-bin.000001	#	Query	#	#	BEGIN
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Xid	#	#	COMMIT /* XID */
mysqld-bin.000001	#	Query	#	#	BEGIN
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Query	#	#	SAVEPOINT `savepoint_1`
mysqld-bin.000001	#	Xid	#	#	COMMIT /* XID */
mysqld-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` PROCEDURE `p1`(IN param INT)
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO savepoint1;
INSERT `t2` VALUES (param);
END;
START TRANSACTION;
SAVEPOINT savepoint1;
INSERT INTO dummy VALUES (1);
RELEASE SAVEPOINT `savepoint_1`;
COMMIT;
END
mysqld-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` PROCEDURE `p2`()
BEGIN
START TRANSACTION;
SAVEPOINT savepoint1;
COMMIT;
END
mysqld-bin.000001	#	Query	#	#	use `test`; CREATE DEFINER=`root`@`localhost` FUNCTION `func`(param INT) RETURNS int(11)
BEGIN
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
ROLLBACK TO savepoint1;
INSERT `t2` VALUES (param);
RETURN 2;
END;
SAVEPOINT savepoint1;
INSERT INTO dummy VALUES (1);
RELEASE SAVEPOINT `savepoint_1`;
RETURN 1;
END
mysqld-bin.000001	#	Query	#	#	BEGIN
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Xid	#	#	COMMIT /* XID */
mysqld-bin.000001	#	Query	#	#	BEGIN
mysqld-bin.000001	#	Table_map	#	#	table_id: # (test.t2)
mysqld-bin.000001	#	Write_rows	#	#	table_id: # flags: STMT_END_F
mysqld-bin.000001	#	Xid	#	#	COMMIT /* XID */
mysqld-bin.000001	#	Query	#	#	use `test`; DROP PROCEDURE p1
mysqld-bin.000001	#	Query	#	#	use `test`; DROP PROCEDURE p2
mysqld-bin.000001	#	Query	#	#	use `test`; DROP FUNCTION func
mysqld-bin.000001	#	Query	#	#	use `test`; DROP TABLE `t` /* generated by server */
mysqld-bin.000001	#	Query	#	#	use `test`; DROP TABLE `t2` /* generated by server */
include/rpl_end.inc
